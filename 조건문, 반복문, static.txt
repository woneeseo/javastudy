< 조건문 >

- 특정 조건을 만족했을 때, 원하는 작업수행을 보장하기 위한 제어문

ex) 만약 ~면,~.
     이럴때는 a, 아니면 b

- 조건문을 언제 사용해야 할까?
	조건에 따라 달리 구현해야 할 때 사용함 (~이면 ~면 ~라면 : if문이다 )

 - 단순 if문 (~면 ~해라.)
	
	if(조건식){
	     실행코드;
	}

 - if ~ else (삼항 연산자의 기본형과 비슷함, ~하면 ~하고, 그렇지 않으면 ~하라.)
	
	if(조건식){
	      실행코드;
	}else{
	      실행코드2;
	}

 - if ~ else if ~ if (다중 if문, ~하면 ~하고, 
		그렇지 않고 ~하면 ~하고, 그렇지 않고 ~하면 ~하고
		그렇지 않으면 ~해라.)
	
	if(조건식1){
	       실행코드1;
	}else if(조건식2){
		실행코드2;
	}else{
	       모든 조건에 맞지 않았을 떄의 실행코드;
	}

 * else는 생략할 수 있음

1. 외부로부터 넘겨받은 정수 a가 10보다 크면, sysout("ok")를 실행.
 = 조건문
 = 10보다 클때만 sysout("ok")를 실행, 10보다 작으면 아무것도 안해도 됨 => 단순if

2. 변수 b가 true이면 return 44; 그렇지 않으면 return 55;를 실행. => if else

3. 변수 c가 10보다 크면 sysout('a'); 그렇지 않고 c가 5보다 크면 sysout('b');,
   그렇지 않고 c가 1보다 크면 sysout('c');, 이것도 저것도 아니면 sysout('d'); 
   =>if ~ else if ~ if (다중 if문)


return => 값을 반환할때도 사용하지만,
	 무반환 매서드에서도 사용된다 (if 조건문을 사용할 경우라던지)
	 이 때는 return 이하의 코드를 실행하지 말고 매서드를 빠져나가라는 의미가 된다.
     
  <->break : break는 switch~case 문만 빠져나가기 때문에 
	         switch~case문 밖에 작성된 식을 실행시킬 수 있으나,
	         return을 사용하면 메서드 전체를 빠져나가기 때문에 switch~case문
	         밑으로 쓰여식 실행코드는 실행되지 않는다.



< switch ~ case 문 >

 - 조건문이다.
 - 조건식을 입력할 때 연산자를 넣지 않는다. 
	왜 ? 내부적으로 == 연산자가 반영되어 있기 때문에,
	      ==, equals() 연산만이 가능하다.

 - case 값: ~break; = if, else if
	/ detault ~break; = else 이라고 생각하면 된다

 - switch 와 case 사이에는 변수 선언이나 초기화를 할 수 없다.
 - switch ~ case 문에서 사용할 수 있는 변수의 자료형은 
		int, Stirng, enum의 세가지만 사용할 수 있다.
 - break; 키워드를 잘 이용해야 한다 (코드가 간결해질 수 있음)
 - case문에서 break;를 지우면 
   다른 case문의 break;가 나올 때 까지 실행되고 조건문 메서드를 빠져나가거나
   default문의 break;에서 종료된다.

	case 4:
	case 6:
	case 9:
	case 11:
		System.out.println("30일 까지 있습니다.");
		break;
	==> 4, 6, 9의 값을 갖는 케이스문은 
	       11의 break; 문에서 메서드를 빠져나가 실행을 종료한다.


* if문이나 switch~case문을 둘 다 사용할 수 있는경우는 
  switch~case문을 우선한다 => 코드를 읽기 더 쉬움



< 반복문 >

 - 특정 코드들을 반복하는 기능
 - 변수명은 주로 i,j,k~ 로 한다.
 - 증감식이 i++인 경우, 조건식은 i<n;
   증감식이 i-- 인 경우, 조건식은 i>=n;
 - 반복문을 사용하기 위해서는 알고리즘을 많이 알고있어야 한다
 - 항상 생각할 것 -> 어떤 기능을 몇번 돌릴것인가?

  < 종류 >
   - for
   - while
   - do ~ while (조건식이 거짓이어도 최소 한번은 실행됨)

 1. for문
	- for()
	- 소괄호 안에 초기화, 조건식, 증감식을 적는다
	- 소괄호 옆 중괄호를 적고
	- 중괄호 안에 반복할 코드를 적는다. 
	- 실행 순서 -> for문 확인-> 초기화(초기화는 for문이 시작될 때 딱 한번만 실행됨)
	  ->조건식(주로 비교연산을 함) -> 조건식이 참이면 중괄호 안 실행코드를 실행
				-> 조건식이 거짓이면 for문을 빠져나간다 
	  ->증감식 ->조건식->조건식이 거짓일 때 까지 실행코드를 실행->증감식
	  ->조건식->증감식...->조건식이 거짓일때->for문을 빠져나감

	public void me1() {
		for(int i=0; i<10; i++) {
			System.out.println("hello world");
		}
		// i는 0부터 시작해서 
		// i가 10보다 작냐? -> 0이니까 작지 -> true
		// 중괄호 안의 실행코드 실행
		// 증감식
		// 조건식으로 가서 비교
		// i가 10보다 작냐? -> 1이니까 작지 -> true
		// 중괄호 안의 실행코드 실행...
		// i가 10보다 작지 않을 때(i>=10)까지 반복하다가
		// i가 10이 되면 반복문을 빠져나간다
	}


2. while 문

	- 어떤 조건으로 반복을 할것인지? 
	- 1. 변수 선언 및 초기화를 한다.
	- 2. while(조건식) : 소괄호 안에는 조건식만 적는다.
	- 3. 중괄호 안에 true일 때의 실행될 코드를 적는다.
	- 4. true일 경우 실행될 코드의 마지막 변수에 대한 증감식을 적는다.



	public void me11() {
		int i = 100;
		while(i>=0) {
			System.out.println(i);
			i--;
		}
	}



< static >

- 주로 보안을 강화해야 할 때 주로 사용
- 메모리의 메서드 영역(클래스 영역)에 존재함
- 프로그램이 실행되면 곧바로 static영역에 로딩 되어 실행 가능한 상태가 됨**
	(객체를 새로 만들어 줄 필요가 없음)
- static 변수/상수/매서드 = class 변수/상수/매서드 = 정적변수
- static 변수/상수는 객체가 몇개가 생성되던 관계없이 무조건 하나만 생성됨
	<->instance 변수 : 객체 생성시마다 매번 생성됨

- static변수 생성하는 법 : static 키워드를 넣고 만들어주는 변수
	 접근제한자 static 자료형 변수명;
  	    ex)   public static int a;

              	으로도 만들지만  	class명.변수명 으로 사용한다. 

	public static int b;
	 -> static 키워드를 넣고 만든 변수
	
	Test.b = 500;
	-> test라는 클래스 명으로 만든 변수

- 클래스 변수는 같은 클래스 내에서 사용되더라도 클래스명.변수명 형식으로 사용한다. 


	public static void me1() {
	// static 메서드는 불러오는 동시에 이미 활성화가 되어있기 때문에
	// 객체가 없이 쓰여진 a는 사용될 수 없다.
		// a는 instance변수이기 때문에 쓰려면 객체를 만들어줘야 한다
		//System.out.println(a); => 오류 발생
		
		Test t1 = new Test();
		// instance변수 a를 쓰기 위해 객체를 설정
		System.out.println(t1.a);
		System.out.println(Test.b);
		// instance변수 a는 객체가 없으면 사용할 수 없다.
		// static변수인 b는 객체가 없어도 사용할 수 있기 때문에
		// 오류가 발생하지 않음 	
	}

- static 초기화

	static {
		company = "hyundai";
	}

	* static 블럭 : static변수를 초기화 해주는 블럭, static변수도 선언과 동시에 초기화 할 수 있고,
		    생성자 안에서 초기화를 할 수도 있으나, static 블럭을 만들어 초기화 하는 방법이 가장 좋다. 