<자바 컬렉션 프레임워크>

- 상자다
- 상자는 상자인데 무엇을 담을 수 있는 상자인가?
- 상자에 무엇이 담겨있는지를 알려주는 것을 Generic이라고 한다.
  (상자에 내용물의 이름을 적는 것)
- 상자의 내용물에 아무거나 넣으면 Runtime Exception이 발생함
- 특정 자료형만 넣을 수 있게 만들어진 상자
- 활용도가 매우 높음 
- 자바 컬렉션 프레임워크 <내용물의 참조자료형>
  (기본자료형은 들어갈 수 없다. - wrapper class로 사용해야함)


- List Interface

- Set Interface

- Map Interface
(자바 컬렉션 프레임워크는 아니지만 사용방법이 자바 컬렉션 프레임워크와 같다)




< List Interface >


-  ArrayList
: List Interface는 인터페이스이기 때문에 인터페이스로는 객체를 생성할 수 없음
따라서 list 자바 클래스 프레임워크에 있는 자료를 사용하기 위해서는 list를 구현한
Arraylist 클래스를 이용한다.

배열처럼 생긴 list
배열은 처음에 크기를 정해주면 크기가 변하지 않지만,
arraylist는 크기를 변경시키는 것이 가능하다.
		
- 만드는 방법 : 자바컬렉션프레임워크 <내용물의 참조자료형>
  List<Apple> list = new ArrayList<Apple>();

- Apple 클래스의 객체'만' 내용물로 들어갈 수 있음		

	list.add(new Apple());
	list.add("안녕"); => 에러발생
	list에서 add( )는 반환형이 있지만 따로 받아주지 않아도 오류나지 않음

- list.add( )

List<Integer> list = new ArrayList<Integer>();
	
	list.add(new Integer(3));
	list.add(4);
	list.add(5);
	list.add(6);

- wrapper class는 auto boxing - auto unboxing이 되기 때문에
참조자료형처럼 값을 입력해줘도 되고, 그자리에서 바로 값을 입력해도 됨.

cf)

List<Map<String, Object>> list = new ArrayList<Map<String,Object>>();
		
	list.add(new HashMap<String, Object>());
		
- map은 인터페이스라서 map으로는 객체를 만들 수 없음
  map을 구현하고 있는 hashmap클래스를 이용해서 Map에 객체를 생성해줌


- list.get( )

	Apple iphone12 = list.get(0);

       list가 가진 요소값을 출력하는 메서드. 인덱스번호를 이용해서 출력함.


- list.set( )

	list.set(list.size()-1, 1.1);
	System.out.println(list.get(list.size()-1));

	값을 설정하는 메서드. (인덱스번호, 원하는 값) 을 입력하면 됨.


- list.remove( )

	list.remove(new Integer(100));

int 자료형으로 입력된 값을 삭제하고 싶을 때 new Integer(인덱스에 저장된 값) 을 입력해주면 됨
int형 자료값과 인덱스가 정수값으로 충돌하면 인덱스로 인식한다.
		
	System.out.println(list);
		
	list.remove(1);
	list.remove(2);
	System.out.println(list);

list에서는 하나가 삭제되면 삭제된 자리로 자료가 당겨짐
[3, 100, 5, 6] 에서 인덱스 1번을 지우면
list의 배열이 [3, 5, 6] 으로 바뀌면서, 다시 인덱스번호가 부여된다.
100이 삭제되어서 인덱스 1번이 5로 변경되었다.
인덱스 2번을 삭제하면 6이 삭제되며 최종적으로 콘솔에 출력되는 값은 [3, 5] 가 남는다.
		
	list.remove(2);
	list.remove(1);
	System.out.println(list);

list에서는 여러가지 데이터를 삭제하고 싶다면 뒤에서부터 삭제한다.
이러한 특성때문에 수정작업이 빈번한 곳에서는 arraylist를 쓰지 않는다. (linked list를 씀)


- list.clear( )

	리스트에 있는 모든 자료를 삭제할 때 사용. 
	자료를 담았던 상자는 그대로 남아있고 값만 사라짐




< set interface >


- Set :  데이터의 중복을 허락하지 않음. 입력순서와 출력순서 사이에 상관관계가 없음
	데이터의 중복은 equals( )로 체크. 
	자료를 넣는 주머니(넣는 순서도 뒤죽박죽 꺼내는것도 뒤죽박죽)

- HashSet

	- 데이터 입력시에는 add( ) 를 씀
	- 데이터를 가져올 때, get( )메서드를 사용할 수 없다 : 
			순서가 뒤죽박죽이기 때문에 인덱스가 없음
	- get( )대신 *iterator( )*로 데이터를 가져옴
	- size( )
	- remove(Object obj) : 인덱스가 없기 때문에 직접적인 객체를 넣어야 삭제할 수 있음
	- clear( )
	- Map<key word, value> 의 키워드를 set으로 만든다(중복을 허용하지 않기 때문에)

