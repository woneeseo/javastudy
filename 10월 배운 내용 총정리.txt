= : 대입연산자

지역(local)변수 : 유지.보수를 편하게 해줌
메서드 안에서 중복되는 데이터는 변수처리.

클래스 안에서 중복되는 코드는 메서드(객체의 행위, 능력, 기능을 함)로 처리한다.
프로젝트 안에서 중복되는 메서드(or 변수 or상수)는 상속으로 처리

<변수 선언공식>
자료형 변수명 = 자료형에 맞는 값;

<자료형>
1. 기본자료형 : boolean char byte short int long float double

2. 참조자료형 : 기본자료형이 아닌 자료형. 
참조자료형 변수명 = new 생성자( );
	- new : 힙메모리에 저장공간을 할당하는 의미
	- 변수 : 객체가 저장된 힙메모리의 주소값을 가지고 있음

<지역변수vs멤버변수>

1. 지역변수 : 메서드나 생성자 안에서 선언된 변수
	- 범위 : 선언 된 순간부터 가장 가까운 } 까지
	- 자료형 변수명; (변수선언)
	- 자료형 변수명 = 자료형에 맞는 값; (선언+초기화)
	- 변수명 = 자료형에 맞는 값; (대입, 대입을 학 위해서는 반드시 선언이 되어 있어야 함)
	- 변수명 = 자료형에 맞는 값; (생성자에서 이런 코드가 있으면 멤버변수의 초기화를 한 것임)

2. 멤버변수 : 클래스의 필드에 선언.
	- 스코프는 해당 클래스 전체에서 사용할 수 있음.
	- 일반적으로 private 자료형 변수명;
	- 초기화는 생성자 안에서 이루어짐
	- 객체의 구성요소의 역할을 함
	- 클래스의 구성요소


<메서드>

- 객체의 기능(=능력=행위)를 표현함
- public 반환형(반환되는 데이터의 자료형) 메서드명(파라미터){
	
	return 자료형에 맞는 값;}
	(반환형이 void가 아닐때 return 값을 가진다)

- 무반환 무파람 : 메서드명( );
- 무반환 유파람 : set( ); , 메서드명(자료형에 맞는 값);
- 유반환 무파람 : get( ) , 반환형과 같은 자료형 변수명 = 메서드명( );
- 유반환 유파람 : 반환형과 같은 자료형 변수명 = 메서드명(자료형에 맞는 값);
	*메서드 호출이 메서드 생성보다 더 중요하다


- 메서드 오버로딩(=오버로딩)
	- 반드시 같은 클래스 안에 존재해야 한다
	- 메서드 이름이 같아야 함.
	- 메서드 파라미터의 자료형과 관련되어 있음.
	- 접근제한자/ 반환형/ 파라미터의 변수명 => 관계없음!
 1. 메서드 파라미터의 갯수가 다르면 오버로딩이 성립됨
 2. 메서드 파라미터의 자료형이 다르면 오버로딩이 성립됨
 3. 메서드 파라미터의 배치 순서가 다르면 오버로딩이 성립됨


<생성자>

- 객체 생성시 값을 제공, 멤버변수의 초기화, 클래스의 구성요소
	- 디폴트 생성자 : 파라미터가 없는 생성자
	- 사용자 생성자 : 파라미터가 있는 생성자

- 생성자가 눈에 안보일 때, 생성자는 몇개 있나? - 1개 (디폴트 생성자가 존재)
- 사용자 생성자가 2개가 눈에 보인다, 생성자는 몇개? - 2개 (디폴트 생성자가 없다)
	==> 이 때는 디폴트 생성자를 직접 입력해 만들어줘야 한다.
- 동적인 객체를 만들고 싶을 때 -> 사용자 생성자를 사용한다.
- 접근제한자 생성자명(파라미터){}
	   ---------- =클래스 명
- this. => 객체 자기 자신. 지역변수와 멤버변수의 변수명이 같을 때 사용
		      (컴파일러가 지역변수를 우선적으로 인식하기 때문에)
- this( ) => 해당 클래스의 생성자를 호출할 때 사용.
	  반드시 생성자의 첫 라인에 작성해야 한다.


<클래스와 객체>

1. 객체 : 국어사전에서 명사, 힙메모리에 저장된 테이터, 실체
	- 참조자료형 객체명 = new 생성자( );
2. 객체는 heap메모리에 저장된다.
3. 반드시 참조자료형으로 만들어진다.
4. 객체가 갖고있는 자원에 접근 또는 사용하고 싶을 때,
	- 객체명.변수명;
	- 객체명.상수명;
	- 객체명.메서드명; 	의 형식으로 사용한다.

5. 클래스 : 설계도의 의미. class라는 키워드가 있어야 클래스다.
6. 클래스는 단독으로 실행될 수 없다. 반드시 객체를 만들어서 실행해야 함!!
7. 클래스의 구성요소 : 멤버변수/상수 , 생성자, 메서드 
8. 클래스는 객체의 구성요소를 표현하는 자료 (=멤버변수)
	  객체의 구성법을 표현하는 자료 (=생성자)
	  객체의 기능을 표현하는 자료 (=메서드)
9. 참조자료형의 변수(=객체=인스턴스)가 갖고있는 자원에 접근하려면 어떻게?
	객체명. 원하는 자원을 선택;


<연산자>

=

+ , - , * , / , %
/ : 정수형에서는 몫만을 나타내는 연산자 
0 0 0 1 1 1 2 2 2 처럼 일정한 배열을 나타내는 수열에서 사용
% : 나머지 연산자, 어떤 수가 배수인지 여부를 확인할 때 사용
0 1 2 3 0 1 2 3 처럼 일정한 숫자의 반복을 나타내는 수열에서 사용

+= , -= , *=, /= , %=

> , >= , <  , <= , == , != (->비교연산자의 결과값은 boolean형으로만 나온다)

&& : 연산에 사용하는 데이터가 모두 true 일때만 true, 하나라도 false가 있으면 false
|| : 연산에 사용하는 데이터가 모두 false일때만 false
! : 값 반전 true -> false / false -> true

++ , -- : 1씩 증가하거나 감소함, 단항연산자 
++a / --a : 즉시 증감해서 a에 대입
a++ / a-- : 다음에 a를 만났을 때 대입됨

&, | , ^, ~

>> , <<

<조건연산자(=삼항연산자)>

(자료형) 변수명 = 조건식 ? 조건식이 참일 때의 값 : 조건식이 거짓일 때의 값 ;
다중 조건 연산을 할 수도 있음
	(자료형) 변수명 = 조건식1 ? 참일때의 값 : 조건식2 ? 참일때의 값 : 조건식3? 참일때의 값 : 거짓일 때의 값 ;


<조건문>

if문 : 상황에 따라 실행코드를 달리하고 싶을 때 사용 (~면, ~라면, ~이면)

- 단순 if 문 : ~면 ~해라.
- if ~ else 문 : ~면 ~하고, 그렇지 않으면 ~해라.
- 다중 if 문 : ~면 ~해라, 그렇지 않고 ~면 ~해라, 그렇지 않고 ~면 ~해라 (, 그렇지 않으면 ~해라.)


switch ~ case 문 : 내부적으로 == 연산만 사용가능, int, String, enum 세가지 자료형만 사용 가능

 - break; : 

<반복문>

- for문 : 몇 회 반복할 것인지 알때 쓰는 코드
- while : 반복을 언제 어떤조건까지 실행할것인지를 알고 있을 때
- do~while : 식이 false여도 한번은 시도해보는 반복문
	for(int i=0; i<20; i++){
		sysout("hello"); 
	}
     - 실행순서 : 초기화 -> 조건식 -> 조건이 참이면 본문 내용을 실행 -> 증감식
	       -> 조건식 -> 조건이 참이면 본문 내용을 실행 -> 증감식 -> 
	       조건식 -> 조건이 거짓이면 for문을 빠져나온다.

- return 의 기능 
	1. 값 반환의 의미
	2. 메서드 실행 중단
- break : 가장 가까운 반복문을 빠져나감
- continue : 해당 회차를 빠져나감 