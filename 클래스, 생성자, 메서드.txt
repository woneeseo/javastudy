<클래스의 구성 요소>

(클래스의 필드 내에 작성할 수 있음)
멤버변수
생성자
(멤버)메서드

* 필드 영역에서는 대입이 성립되지 않음
* 필드 영역에서는 매서드 호출이 되지 않음
* 메서드 영역 안에서 새로운 매서드 생성? 안됨, 호출만 가능!

- 멤버변수나 메서드를 호출(=사용)하려면 
반드시 객체(=참조자료형의 변수)가 있어야 한다.
	클래스 변수명 = new 생성자( );

- 생성자의 역할 : 멤버변수의 초기화, 
객체(=참조자료형의 변수) 생성할 때, 자료형에 맞는 값으로 사용됨.

- 멤버 변수의 역할 : 객체의 구성요소를 표현함. (ex) 자동차의 엔진, 바퀴, 핸들등을 만드는 것)
- 지역변수의 역할 : 메서드 안에서 중복되는 값을 표현함.
- 메서드의 역할 : 객체의 기능(=능력)을 표현함 
	        클래스 안에서 중복되는 값'들'을 표현함. (타 언어의 함수와 같은 기능)

- 디폴트 생성자는 다른 생성자가 눈에 안보이면 존재한다.
- 다른 생성자가 눈에 보이는데, 디폴트 생성자가 안보이면 없는것이다.
- 클래스 생성할 때는 무조건 디폴트 생성자를 만들어줘야 한다.

- this : 객체 자기 자신. 
	 this를 왜 붙이느냐? 지역변수와 멤버변수가 이름이 같으면 
	컴파일러는 지역변수로 인식한다. 
	만약에 멤버변수를 가리키고 싶다면 this.멤버변수 로 접근하면 됨.

this( ); => 생성자 호출, 해당 클래스 안에서만 사용
	다른 생성자의 첫번째 라인에서만 호출 가능
	==> 번거로운 조건때문에 메서드를 호출 해 사용하는 일이 많음




< 객체와 클래스 >

- 객체 = object = instance = bean(컨테이너가 자동으로 만든 객체) = entity(DB) 
 	= domain (UML에서 쓰는 용어)

- 객체는 국어사전의 명사다.
	ex) 한라산
	Mountain hallasan = new Mountain("한라산");
	     자동차
	Car bmw = new Car( );

- heap 메모리에 저장된 데이터.
- 실체 ( ex 실제 건물은 객체, 건물의 설계도는 클래스)

* 기본자료형은 객체로 설정할 수 없음.
* 객체 생성법
      참조자료형 변수명(=객체명=레퍼런스) = new 생성자( );
      Test1 t1 = new Test1();

* 객체가 갖고있는 자원(구성요소, 기능)을 사용하는 방법
      객체명(=변수명=레퍼런스) . 변수명(or 메서드명);
      kim0.setAdderss("seoul");

- 클래스는 객체의 구성 요소를 표현한 자료이다.
- 객체 생성법을 표현한 자료이다.
- 객체의 기능을 표현한 자료이다.
- 일종의 설계도
	자동차 설계도 :  자동차 = 클래스 : 객체

- 클래스의 구성요소 : 멤버필드 (멤버변수/멤버상수), 생성자, 메서드 
- 클래스는 절대로 단독으로 실행되지 않는다. -> 객체를 생성해야 사용할 수 있음
	클래스를 만드는 이유? 객체를 생성하겠다. 
	그리고 그 객체로 뭔가 작업을 하겠다는 의미
	클래스는 설계도이기 때문에 단독으로 실행될 수 없다!

- class라는 키워드가 있어야 클래스이다. 클래스 필드 안에서 내부클래스를 만들수도 있음.
	(예외 -> 익명의 내부 클래스 : class라는 키워드가 없는 클래스)

+ instance 변수 : 멤버변수의 일종. 객체가 만들어질 때마다 힙메모리에 새로 만들어짐

ex)
 Car car1 = new Car("K7", "서울34자1234", 4000);
 Car car2 = new Car("BMW", "서울33사9876", 5000);
 Car car3 = new Car("SM5", "경기31자1234", 4000);
		--------------------------------

		객체가 만들어질 때마다 새로 만들어지는 변수

+ 자원 : 객체가 가지고 있는 기능이나 객체의 구성요소 (멤버 변수나 상수, 메서드)



< 생성자 >

- class의 멤버변수를 초기화하는 클래스의 구성요소
- 생성자는 반환형이 없다**

- 생성자의 기능
1. 클래스의 멤버변수를 초기화
2. 참조자료형의 자료형에 맞는 값을 제공함(=객체 생성방법)
객체 설정할 때, 클래스 변수명 = new 생성자( );
디폴트생성자로 객체를 만들면 디폴트값으로 설정됨
사용자생성자로 객체를 만들면 사용자생성자 값으로 설정됨

생성자는 디폴트 생성자와 사용자 생성자로 나뉜다.

- 디폴트 생성자 : 파라미터가 없는 생성자. 
     1. 클래스에 생성자가 없으면, 디폴트 생성자가 눈에 보이지 않아도 존재함.
     2. 클래스에 생성자가 있으면, 디폴트 생성자가 눈에 안보이면 존재하지 않음.

- 사용자 생성자 : 파라미터가 있는 생성자.

- 생성자는 클래스 외부에서 호출하면 새로운 객체가 만들어지지만,
  같은 클래스 내에서 호출하면 그 생성자에 있는 코드를 실행하라는 의미가 된다.
  대신 생성자의 맨 첫번째 줄에만 사용해야 한다. 

             public Test1(long a) {
		this(); 
		------ (같은 클래스 내에서 호출된 생성자의 모습)
		System.out.println(a);
	}

- 디폴트 생성자와 사용자 생성자를 언제 구분해서 사용해야 하나?
1. 맘대로 하슈
2. 사용자 생성자로 하던지 
(마우스우클릭 source -> generate consturuct using filed어쩌구,
-> 파라미터에 포함하고 싶은 것 골라서 선택하고 generate)

디폴트생성자+겟셋메서드로 하던지 둘중에 하나 골라서 쓰면 됨
디폴트 생성자 만들고 source -> generate getters and setters
-> 사용하고 싶은 변수들 선택해서 generate)


*익명의 객체 : 변수명을 알 수 없는 객체. 한번만 사용하는 객체.
참조자료형에서 많이 사용됨

 - 멤버변수가 있다? = getters and setters / 사용자 생성자 반드시 만들어 줄 것.


<메서드>
(= 오퍼레이터 라고도 함)

 - 메서드란 : 어떠한 특정 작업을 수행하기 위한 명령문의 집합
	객체의 기능(=능력)을 부여하기 위해 만듦
 - 매서드들 간의 중복되는 여러개의 코드를 하나의 메서드로 묶어서 처리할 수 있음
 (+ 프로젝트 내에서 각 클래스 중에 중복되는 코드가 있을 경우에는 상속으로 처리함) 

<매서드 만들기>

반환형이 없다(void) : 동작(=기능)의 수행이 목적이다
반환형이 있다 : 동작(=기능)을 수행한 후 결과값을 제공하는 것이 목적이다.

접근권한자 반환자 매서드명(파라미터 값){
}
ex)
	public void plus21() {
		System.out.println(b++);
	}

1. 무반환 무파람의 경우에는 반환자 -> void 넣어주고, 
파라미터 값 들어갈 소괄호에 아무것도 없게 해주면 됨
항상 같은 내용만 출력 된다.
   
   - 생성 예제
     public void me1( ){
         sysout("무반환 무파람");
     }

   - 호출(사용) 예제
     ⓐ 같은 클래스 내에서는 me1( );
     ⓑ 다른 클래스에서는 변수 선언하듯 객체 생성 후
        객체명.me1( );

2. 무반환 유파람의 경우에는 반환자 -> void는 같은데,
파라미터 값(소괄호)에 매개변수를 넣어준다.
매개변수는 멤버변수와 같은 형태로 넣어주고, 
여러개의 매개변수를 설정하고 싶을 때는 컴마(,)를 사용해 구분해줌
파라미터가 있기 때문에 동적인 기능을 할 수 있음

   - 생성 예제
     public void printScore(String name, int score ){
         sysout(name+" " + score + "점" );
     }

   - 호출(사용) 예제
     ⓐ 같은 클래스 내에서는 printScore("kim", 86 );
     ⓑ 다른 클래스에서는 변수 선언하듯 객체 생성 후
        객체명.printScore(("김유신", 100 );

ex)
public void printScore(String name, int score){}

3. 유반환 무파람의 경우 -> 반환자를 반환할 자료값에 맞는 자료형을 넣어주고
파라미터 값 들어갈 소괄호는 비워둔다.

만약에 내가, 반환값이 20(정수)인 매서드를 만들고 싶다면,

public int getInt(){
         return 20; 
} 

이런 식으로 반환값이 정수 20을 갖는 매서드를 만들어준다.

데이터의 값만 반환됨 
반환형 = 반환하는 값과 같은 자료형으로
참조자료형의 반환형은 생성자명!

public Test12 giveMeTheMoney() {
         --------		
	return new Test12();
      		  ----------
값을 반환할 때는 return을 꼭 써야함

반환! 

출력은 메모리에 저장 안됨 출력하고 끝
반환은 메모리에 저장됨 값을 갖고있는것임

유반환 무파람을 출력하고 싶으면 
int re1 = m4.giveMeTheMoney();
---  
반환형 변수명 =(대입연산자) 



4. 유반환 유파람의 경우 -> 반환자에 반환할 자료값에 맞는 자료형을 넣어주고
파라미터에 매개변수를 선언해주는 것을 말한다.

만약 내가, 반환값이 정수이고 메인메서드에서 값을 조정할 수 있는
동적인 매서드를 만들고 싶다면,

public int getInt2(int a){
         return a;
}

로 매개변수 자리에 int 형 자료를 값으로 갖는 변수 a를 설정해 준다.
메인메서드에서 호출하여

Method aa = new Method();
int i = aa.getInt2(int를 자료형으로 갖는 모든 정수);

로 설정해주면 메인메서드에서 동적인 값을 자유자재로 가질 수 있다.



브라우저나 웹에 출력하고 싶을 때 사용
동사무소에서 등본 떼고 싶을 때,
내 주민등록번호를 입력하는 행위(파라미터를 주는 것)
그리고 내 주민등록번호로 등본을 찾아 불러오는 행위 (유반환)

콘솔에서 말고 브라우저나 웹에 저장된 값을 불러오기 하는게
유반환 유파람

값을 반환할 떄는  get 이라는 method 를 이용할 것

리턴값은 하나만 가능하다.
여러개를 리턴하고 싶으면 배열로 해야댐

클래스를 리턴값으로 가질 수도 있고 
반환형에 맞는 값을 가질 수도 있음

포털사이트에 검색어를 입력하면(유파람) 데이터를 반환하고 브라우저에 출력하는것
데이터베이스에 있는 내용을 가져올 때 주로 사용

콘솔창에
com.naver.MethodTest2@5aaa6d82
이런 주소값이 나오면 잘 된거야 이상ㄴㄴ




<get/ set 메서드>

* 멤버변수는 99.9999%로 접근제한자를 private로 설정한다.
private 접근제한자는 같은 클래스에서는 접근을 허용하지만.
같은 패키지나 다른 패키지에서는 접근을 거부한다.

하지만 객체의 멤버변수는 값을 수정하거나 값을 활용할 수 있어야한다.

그렇다면 private으로 설정된 멤버변수의 값을 어떻게 수정하고 반환받을 수 있나?
get / set 메서드를 이용하면 가능하다.

멤버변수가 있으면 getters and setters를 꼭 작성해줄것.

get은 멤버변수에 담겨진 데이터 가져올떄
set은 멤버변수에 데이터를 줄때 저장할때

get 메서드는 유반환 무파람 메서드(set에서 가진 값을 반환! 해주는것)
set 메서드는 무반환 유파람 메서드(설정해준 값을 갖고만 있는거야)




public class Dog {
	
	private String name;
	private int age;
	
	public Dog() {
		
		name = "멍멍이";
		age = 23;
		
	}

내가 dog라는 클래스에서 멤버변수로 값을 문자열로 갖는 변수 name;이랑 
값을 정수로 갖는 변수 age;를 설정했어
그리고 디폴트 생성자에서 name에 멍멍이, age에 23을 넣으면서 초기화해줌.

그럼 이제 멤버변수 name은 쭉 멍멍이라는 값만 갖고 있는거고
멤버변수 age는 23이라는 값만 가지고 있는거야.

근데 객체의 멤버변수는 메인클래스에서 값을 수정하거나 활용할 수 있어야 한다
그래서 다른 클래스에서도 멤버변수에 접근해 활용할 수 있도록 해주는 메서드가

get / set 메서드다.

 	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
 

항상 짝으로 다님.
이제 set 메서드를 이용해서 name에는 문자열을 가지는 값 아무거나 넣을 수 있게
파라미터를 설정해주고 그 값을 갖고있는게 해줘 (무반환 유파람)
this. ->이 클래스에서 초기에 설정한 멤버변수를 가리킨다는 의미래


set 메서드가 가진 값을 내가 화면이나 콘솔에 출력을 해야하잖아
그 때 사용하는게 get 메서드야
get 메서드는 값을 주지는 않아 (무파람), 반환만 해줄 뿐(유반환)
유반환 메서드는 출력하기 위해서 return값을 가지니까
반환자와 같은 리턴값을 지정해 줘야 해

아까 set에서 멤버변수 age에 정수 값을 갖는 age라는 변수를 대입해서
이제 멤버변수 age는 어디서든 접근해서 수정하고 활용하는게 가능하게 됐어
이제 그 age의 값을 출력해주려고 get메서드를 사용하는데
우리가 출력하고 싶은 값은 age잖아
그 age가 가지고 있는 자료형이 int 형이야
그래서 값이 가지고 있는 자료형을 반환자명으로 써줘야하니까
int 형으로 반환자를 적어주고, 파라미터는 비워둬
얘는 값을 주는(동적인 활동을 하게 하는) 매서드가 아니기 때문에 비워놔야 함
return을 이용해서 나는 age라는 값을 출력할거야 해서
메인 클래스에 호출을 해주면 원하는 대로 값을 바꿔서 활용이 가능해

모르겠으면 걍 외워 ㅋ
멤버변수 있으면 반드시 getters and setters 해주면 돼
 



<매서드 오버로딩> (<-> 메서드 오버라이딩)

- 생성자와는 관련 없음
- 메서드와만 관련있음
- 변수명도 영향을 끼치지 않는다
- 반환형도 영향을 끼치지 않는다

**오직 파라미터의 자료형과만 관련이 있다**

- 선결 조건.(and조건)
(두가지 조건을 모두 만족해야 함)

1. 같은 클래스에서 생성된 매서드들이어야 한다.
2. 반드시 메서드의 이름이 같아야 한다.

- 매서드 오버로딩의 성립 조건.(or조건)
(세가지 조건 중 하나만 만족해도 메서드 오버로딩이 성립함)

1. 파라미터(=매개변수)의 개수가 다르면 메서드 오버로딩 성립
2. 파라미터의 개수가 같은데 파라미터의 자료형이 다르면 메서드 오버로딩 성립
3. 파라미터의 개수가 같고 파라미터의 자료형도 같을 때,
   파라미터 자료형의 배치 순서가 다르면 매서드 오버로딩 성립.

public class Test3 {
        -------
       1. 같은 클래스 내에서
	
	public void printDa() {
		--------- ==
		System.out.println("메서드 오버로딩");
	}
	
	public void printDa(int a) {
                           --------- ====
		System.out.println(a);
		
	}
	
	public void printDa(long a) {
                            --------- ====
		System.out.println(a);
	}
	
	public void printDa(Dog a) {
                           ---------- ====
		System.out.println(a);
	
	}
	
	public void printDa(Cat a) {
                           ----------- ====
		2. 매서드 명이 모두 동일하고 
		3. 파라미터의 자료형이 다르므로

		System.out.println(a);
	}

}

		=> 메서드 오버로딩이 성립한다. 



- 매서드 오버로딩을 사용해야 하는 때
메서드들의 전반적인 기능이 같은데, 파라미터의 자료형이 다를 때.
(자료형의 갯수가 다르거나, 파라미터의 자료형, 배치순서가 다를 때)

- 매서드 오버로딩과 관련 없는 것들

1. 접근제한자
2. 반환형
3. 파라미터의 변수명
4. 메서드의 본문 내용

- 매서드 오버로딩의 장점은 매서드 호출 할 때 나온다.

		t3.printDa();
		t3.printDa(new Dog());
		t3.printDa(new Cat());

(하나의 매서드 명으로 여러가지 자료형의 파라미터를 호출해도 오류가 생기지않음)

<매서드 오버로딩 vs 매서드 오버라이딩>

메서드 오버라이딩의 전제조건 : 상속관계가 성립하는 두 클래스에서 자식클래스가 부모클래스의 
메서드 내용을 재정의(수정/삭제/추가)하는 것을 의미함