< Reflection - 문자열로 객체 만들기 >

- 일반적으로 객체를 만드는 방법에는

1. 자료형 변수명 = 자료형에 맞는 값;
2. 자료형 변수명 = new 생성자( );

두가지가 보편적이나,

+ 문자열을 이용해 객체를 만드는 방법 : reflection 을 사용할 수도 있다.
(Spring Framework, JSPsuvlet에서 객체를 만드는 방법)
: DB와 map과 Reflection을 잘 활용하면 코드의 유지보수가 획기적으로 쉬워진다.

 * reflection을 만드는 방법 *

1. menu에 대한 테이블을 만듦.
2. 해당 테이블에 menu를 full package명으로 저장
3. menu에 대한 DTO클래스를 만듦
4. menu에 대한 DAO클래스를 만듦
5. main( )에서 menu목록을 전부 가져옴 (for)
6. 그 메뉴들을 모두 map에 저장함
7. reflection을 이용해서 특정 메뉴에 대한 객체를 생성
8. 그 객체가 갖고있는 execute( ) 호출


// reflection 구현하기//
// 1. 먼저 DB테이블에 클래스의 풀 패키지명을 값으로 갖는 테이블을 하나 만든다.
		
// CREATE TABLE menus(
// fullname VARCHAR2(100) PRIMARY KEY
// )
		
// 2. 테이블에 값을 추가한다.
// INSERT INTO menus VALUES ('com.naver.InsertCommand')
// INSERT INTO menus VALUES ('com.naver.SelectCommand')
// INSERT INTO menus VALUES ('com.naver.UpdateCommand')
// INSERT INTO menus VALUES ('com.naver.DeleteCommand')
// INSERT INTO menus VALUES ('com.naver.EndCommand')
		
// 3. DAO/DTO 클래스를 만든다.
		
// 4. main()에서 menu테이블이 갖고있는 값을 map에 하나씩 추가해준다.
		
Map<Integer, String> menus = new HashMap<Integer, String>();
		
MenuDAO dao = new MenuDAO();
List<String> list = dao.select();
		
for(int i =0; i<list.size(); i++) {
	menus.put(i, list.get(i));
}
				
Scanner sc = new Scanner(System.in);
		
while (true) {
			
	System.out.println("메뉴를 선택하세요.");
			
// 5. map에 추가해 준 값을 반복문을 통해 가지고온다.
			
	StringBuffer sb = new StringBuffer();
	// StringBuffer는 문자열을 이어서 출력할 수 있게 함
	// String str = i+": "+com2+", "; 와 같지만
	// 저장용량을 덜 차지하는 장점이 있다.
			
	for(int i=0; i<list.size(); i++) {
		String fullname = list.get(i);
		// 리스트에서 가져온 값(풀패키지명을 적은 문자열)을 str로 지정해서
		// forname의 파라미터 값으로 넣어서 class객체를 만든다.
		Class<?> testClass2 = Class.forName(fullname);
		// 만들어진 클래스 객체를 이용해서 생성자를 만들어내고
		Constructor<?> cons2 = testClass2.getConstructor();
		// 이 생성자를 통해서 객체를 만들어낸다. 
		Command com2 = (Command) cons2.newInstance();
				
		sb.append(i);
		sb.append(": ");
		sb.append(com2.toString());
		sb.append(", ");
				
		// 반복문을 통해서 메뉴를 출력할 수 있고
				
	}
			
	System.out.print(sb.toString());
	System.out.println();
	int idx = sc.nextInt();
	sc.nextLine();
			
	String str = menus.get(idx);
	// 메뉴의 idx번 인덱스가 가지고 있는 풀패키지명을 가져와라.
	// (idx는 콘솔에서 입력하는 값임)
		
	Class<?> testClass = Class.forName(str);
	Constructor<?> cons = testClass.getConstructor();
	Command com = (Command) cons.newInstance();
	// 메뉴를 출력하는 것과 동일한 방법으로 reflection한 뒤
	// 생성된 객체를 이용해서 execute()에 접근할 수 있다.
			
	com.execute(sc);
	(콘솔에서 입력받은 idx번 인덱스를 가진 풀패키지명에 접근해,
	그 패키지가 가지고 있는 execute( )를 기능하게 함)
			
	// reflection의 장점은 
	// 기존에 배웠던 방법에서는 클래스가 추가되면 무조건
	// 메인을 수정해야 했다 (배열에 추가하거나, 자바 컬렉션 프레임워크에 add함)
	// 하지만 reflection으로 객체를 설정해주고
	// 테이블에 value 추가 + 클래스 추가 만 해도 
	// 메인을 손 댈 필요 없이 기능 추가 및 삭제가 가능해진다.
	// 유지보수가 매우매우매우 편리함!


==> JSP Suvlet 게시판 프로젝트 할 때 사용할 것임**
(다중 if문으로 구현한 코드를 reflection을 이용해 바꿔야 함)






톰캣 (컨테이너이자 서버로 사용)
톰캣 7 버전을 다운받으면 됨

localhost:8089 > 톰캣 다운로드 성공했다~ 화면 나오면 ok
포트 번호 80 -> 포트번호를 적지 않아도 로컬호스트로 접근 가능

포트번호로 사용할 수 있는 범위 : 0~65534 
실제로는 0~1023까지는 시스템포트 - 사용불가
1024~65534 사이의 포트번호를 사용해야 한다.

8080은 오라클에서 사용하는 포트번호이기 때문에 8080 제외하고는 
80으로 시작하는 번호 무엇을 사용하든 ok

톰캣과 이클립스를 동시에 실행하면 포트에서 충돌이 일어남
이클립스로 작업을 시작할 때는 톰캣이 꺼져있는 상태로 작업을 해야 함



web.xml : 환경설정파일 / 배포서술자 / Deployment Decreiptor / DD 

웹 프로그래밍은 메인메서드가 없음.
실행할 때는 Run on surver를 선택한다. (지정해 준 로컬호스트 서버에서 결과 확인 가능)
window -> wep browser -> chrome 을 선택해서 출력하기
(요즘은 웹 브라우저 기본값으로chrome을 사용하기 때문에)

css로 미디어파일 배치 (인테리어)
tag 기본 구조를 생성 
java Script 
JSP 화면구현
suvlet 컨트롤러 구현
DB작업은 class로


c# 은 ASP
C나 C++ 은 PHP


1. eclipse의 workspace를 변경 (workspace_html) -> EE버전인지 확인할 것
2. tomcat 설치 (8089 포트 사용함, ezen/ezen)
3. 이클립스에서 servers 폴더에 서버 생성
4. 다이나믹 웹 프로젝트 메뉴를 통해 프로젝트 생성
5. WepContent 폴더에 a.html 파일 생성
6. <!DOCTYPE html> = html5 문서임을 알려주는 태그
7. <html> </html> = html문서의 시작과 끝을 알려주는 태그
8. <head> </head> = 문서의 설정과 관련된 정보를 가지고 있는 태그
9. <body> </body> = 브라우저에 출력해서 클라이언트에게 보여주는 내용을 담고있는 태그
10. <a> </a> = 링크나 북마크를 걸 수 있는 태그 
		ex)<a href="https://www.naver.com">naver</a>
	        		( href를 이용해서 url주소를 넣어주면 됨)
		ex)<a href="#z">북마크 기능</a>
			(#은 id를 나타낸다. id값이 z라는 곳을 북마크 했다는 의미)
			(id를 중복으로 사용해서는 안된다 - 선언은 되지만 사용해선 안됨)
11. <br> = 줄바꿈
12. <p> </p> = 문단 태그  (<br>을 쓸 필요 없이 앞 뒷 문단에서 자동으로 줄바꿈 됨)
13. <div> </div> = 단락 태그 (<br>을 쓸 필요 없이 앞 뒷 문단에서 자동으로 줄바꿈 됨)
14. <input> = 입력창을 만들 수 있는 태그
	input 태그는 form태그에 감싸져있어야만 효용성이 있다.
	
	<form action="b.html">
		<input name="id" placeholder="ID를 입력하세요.">
		<input type="submit" value="로그인">
	</form>
	=> input의 타입값을 submit으로 주면, 버튼 역할을 한다.
	=> 로그인 버튼을 누르면 어디로 갈 것인가? -> form태그의 action에 주소값을 준다.
	=> 정보를 잘 넘겨받으면 주소값+쿼리스트림이 생성된다
	
	http://localhost:8089/HelloWorld/b.html?id=teacheryo&pw=123456
	쿼리스트림은 띄어쓰기 하면 안됨
	파일명다음 ? 로 파라미터를 집어넣고, 파라미터가 여러개일 경우(id/pw) & 로 연결
	파라미터네임(id,pw)/파라미터 밸류(teacheryo, 123456) 는 =을이용해서 연결되어 있음


브라우저에 에러가 나면 F12 개발자모드를 이용해서 확인할 수 있음


