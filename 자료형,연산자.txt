<자료형의 구분>

기본자료형과 참조자료형
참조자료형은 기본자료형이 아닌 것이고
기본자료형은 8가지
기본자료형을 또 두가지로 나눠보면
수치형 자료형 (실수형 자료형, 정수형 자료형, char) 
비수치형 자료형 (boolean) 으로 나뉜다.

*char 는 아스키코드를 나타낼 수 있는 수치형 자료형이다.
Enter = 13,    숫자 0 = 48,     대문자 A = 65 ,     소문자 a = 97


<참조자료형의 변수선언 방법>

참조자료형은 새로운 메모리 공간을 할당받아야 하기 때문에
기본자료형과 메모리에 저장되는 형태가 완전히 다르다

Object : 모든 자료형을 아우를 수 있는 자료형
Dog 클래스 : 참조자료형
String 클래스 : 참조자료형
Command 인터페이스 : 참조자료형
int[] : 참조자료형 ( int[] = 배열)
(참조자료형은 대부분 첫글자를 대문자로 적어준다)


자료형 변수명(reference) = new 자료형 ();
        ---------------------         -------
       참조자료형으로 만들어진      생성자 = 자료형
       변수명은 레퍼런스라고 함

 new = 메모리에 새로운 공간을 할당해달라고 하는 명령어


<지역변수>

지역변수 : 클래스의 필드 외에서 선언된 변수
선언이후 ~ 해당 중괄호의 종료 표기( } )까지 
지역(local)변수는 선언되고나서부터 사용할 수 있음

ex)           System.out.println(i); (변수 선언 전 사용 ; 에러남)
               int i = 56;
	 System.out.println(i);
	 
 => 지역변수를 선언하기 전에 변수를 입력하면 인식못함

- 일반적으로 지역변수는 선언과 동시에 초기화
(* 초기화 : 변수 선언과 동시에 값을 대입하는 것 / 생성자 학습할 때 다시 나옴)

자료형 변수명 = 자료형에 맞는 값;

ex) 	int b = 33;


매개변수 : 이전 클래스나 메서드에서 설정한 변수를 
다음 클래스/매서드에서도 사용할 수 있도록 설정해준 변수

 public Dog(int c) {
               ------- 스코프 안에서 선언된 변수보다 사용되는 영역이 넓음 


<member변수>

클래스의 필드 영역에서 선언된 변수, 클래스 영역 전체에서 유효
	      - 객체의 구성 요소 *

-  멤버변수는 선언만 함.
자료형 변수명 ;

ex)	 String master;
	 int age;

<멤버변수의 디폴트값>

기본자료형
boolean - false
char - 공백
byte short int long 0
float double 0.0

참조자료형 - null


member(멤버 필드 영역에서의 생성자와 메서드) 들은 순서를 바꿔 사용해도 에러x
멤버끼리는 사용하는 순서가 중요하지 않다.

        클래스

	멤버필드 작성 (멤버변수/멤버상수)

	생성자
	
	메서드 

순으로 작성해야 함.


생성자와 메서드 차이 ; 반환값(void)가 없음


<대입>

변수 선언과 함께 => 초기화
변수 선언 이후 => 대입


반환형 ; 반환되는 데이터(값)의 자료형
ex) void : 반환값이 없을 때 사용. 



<연산자>

- 연산자 : 연산 기호
- 사칙연산 : + , - , * , /

* 산술연산자 : + - * / % *

+ : 연산자 앞,뒤에 있는 숫자를 더하라는 의미 (문자열과의 덧셈도 가능)
- : 연산자 앞에 있는 숫자에서 뒤에 있는 숫자를 빼라는 의미
/ : 정수에 관한 몫을 알려주는 연산자
	0000 1111 2222 3333 4444 ....
	같은 숫자가 n번 반복된다? / 연산자를 사용한다. (ex 알고리즘)

% : 나머지를 나타내는 연산자
	0123 0123 0123 0123 0123 ...
	특정 범위의 숫자가 계속 반복된다? % 연산자를 사용한다.
	(반복되는 숫자중에서 가장 큰 수 +1 로 나누었다고 생각하면 됨)
	배수를 확인하고 싶으면 % 연산자를 써야함

* 대입 복합 연산자 *

= (대입연산자) : 오른쪽의 값을 왼쪽에 대입하라는 의미
d = e; : e가 갖고있는 객체의 heap메모리 주소를 d에게 대입하라
	(결국 d가 e가 가진 객체의 메모리 주소를 가지게 됨)

+= : 왼쪽값과 오른쪽 값을 더해서 왼쪽항에 대입해줘라.
ex. 
	1. a += b; ---> a = a + b;
	(a와 b의 합을 a에 대입해줘라) 
	2. b += b; ---> b = b + a;
	(b와 a의 합을 b에 대입해줘라)
	=> 이 때, 1번과 2번의 값은 같지 않다.(교환법칙이 성립하지 않는다)
   
-= : 왼쪽값과 오른쪽 값을 빼서 왼쪽항에 대입
*= : 왼쪽값과 오른쪽 값을 곱해서 왼쪽항에 대입
/= : 왼쪽값과 오른쪽 값의 나눠진 몫을 왼쪽항에 대입
%= : 왼쪽값과 오른쪽 값의 나눠진 나머지를 왼쪽항에 대입

대입복합 연산자에서는 무조건 대입연산자(=)이 뒤에 있어야 함.
0으로 어떠한 숫자를 나눠서는 안된다.

* 비교 연산자 *
(비교 연산자의 연산결과는 boolean값으로 도출됨 - true/false)
(반복문/조건문등의 제어문을 만들 때 자주 나온다.)
> : 크다.  a > b; ----> a는 b보다 크다.(b는 a보다 작다x)
		  (프로그래밍은 왼쪽이 기준) 
>= : 크거나 같다.  a >= b; a는 b보다 클수도 있고 같을 수도 있다.
< : 작다. a < b; a는 b보다 작다.
<= : 작거나 같다. a <= b; a는 b보다 작을수도 있고 같을 수도 있다.
== : 같다. a == b; a와 b는 같다.
!= : 안 같다. a != b; a와 b는 안 같다.

* 논리 연산자 *
(boolean 논리연산자 boolean 형태로 사용)
(연산 결과가 true, false 두가지로 나온다)

&& : 그리고 ( and and ) 연산에 참여한 데이터가 전부 ture일 경우에만 true값이 반환된다.
		     연산에 참여한 데이터가 하나라도 false가 있으면 false값을 반환함
|| : 또는 ( or or ) 연산에 참여한 데이터 중 하나라도 true가 있는 경우, true값이 반환됨
	         false가 반환되는 경우 : 연산에 참여한 데이터 모두 false일 때 false가 반환됨
! : 아니다, 반대다 ( not ) 데이터의 값을 반전시킴 ( true -> false / false -> true )

* 증감 연산자 *
( + 대입연산자가 없는 연산자 : 단항연산자)
++ : 1씩 증가.

	* ++이 변수 앞에 오면(++a), 변수의 값이 1만큼 증가함
	* 그리고 그 증가된 값은 곧바로 변수에 대입 됨.
			   --------
	* ++이 변수 뒤에 오면(b++), 변수의 값이 1만큼 증가함
	* 그러나 그 증가된 값은 나중에 해당 변수를 호출할 때 대입됨

-- : 1씩 감소.



* 조건 연산자 *
(= 삼항 연산자 : 항이 3개 있음)

변수명 = 3 > 4 ? "hello" : "no";

(자료형) 변수명 = 조건식 ? 참일때의 값 : 거짓일때의 값;
(자료형) 변수명 = 조건식 ? 참일때의 변수 : 거짓일때의 변수;
(자료형) 변수명 = 조건식 ? 참일때의 반환형이 있는 메서드 : 거짓일때의 반환형이 있는 메서드;

Q1. (	) b = false ? new Dog(1) : new Dog(33);
    (	)에 들어갈 자료형은? 

Dog


Q2. int a = 3;
     int b = 5;
정수형 변수 c의 값은 a가 b와 같으면 44이고 그렇지 않으면 33이다.
변수 c를 선언하시오.

int c = a == b ? 44 : 33;


* 비트 연산자 *
(주어진 숫자를 이진수로 바꿔서 비트연산을 함)

& : 이진수 덧셈할 때, 둘 다 1일경우에만 1	
| : 이진수 덧셈할 때 둘중 하나가 1일 경우에 1
^ : 이진수 덧셈할 때 숫자가 같으면 0, 숫자가 다르면 1 (exclusive or)
     (입력값이 같은지 아닌지 확인하기 위해 사용)
~ : 부호 반전 연산자 (주의 : 양수에서 음수로 부호가 반전 될 때에는 +1
		         음수에서 양수로 부호가 반전 될 때에는 -1 을 해준다)

* 시프트 연산자 *
(주어진 숫자를 이진수로 바꿔서 비트연산을 함)

>>n : (라이트시프트 연산자) 왼쪽에서 오른쪽으로 이동 (2^n만큼 나누는 효과가 있음) 
<<n : 오른쪽에서 왼쪽으로 이동 (2^n만큼 곱하는 효과가 있음)

=> 나머지(%)는 무시하면 됨


