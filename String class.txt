<String class>
  
  * String class의 객체 생성법

1. 명시적 객체 생성법 : 약속된 방식에 따라 객체를 만드는 방법
명시적으로 객체를 생성하면 객체는 힙메모리 영역에 생성됨.
String msg = new String("hello");

String msg1 = new String("a");
String msg2 = new String("a");
System.out.println(msg1 == msg2);

하면 결과값은 false가 출력된다. 
왜? 힙 메모리에 생성되는 객체는 만들때마다 새로운 메모리를 할당받기 때문에 같은 객체가 아니다


2. 암시적(묵시적) 객체 생성법 : 임의의 방법으로 객체를 만드는 방법 
암시적으로 객체를 생성하면 객체는 리터럴 영역에 생성됨.
==> 리터럴 영역에 생성된 객체는 하나만 생성되기 때문에 

String msg = "hello";

String msg3 = "a";
String msg4 = "a";
System.out.println(msg3 == msg4);

했을 때 결과값으로 true가 출력된다.


===> 데이터가 같을 경우에 같은 객체로 인식하게 하는 방법 : 변수명.equals(비교할 변수명);
===> 참조자료형에서는 ==(동일성비교) 안씀! 
         참조자료형에서 비교연산은 무엇을 통해 이루어질까? equals (동등성비교)

	>동일성 비교 vs 동등성 비교<
	1. 동일성 비교 : 데이터가 같은지 데이터와 그 저장 위치까지 확인해서 비교함
	2. 동등성 비교 : 데이터끼리만 비교해서 같은지 확인함


-  String class는 불변적 성격을 가진다. 
   이러한 성격 때문에 문자열이 계속해서 누적되는 경우에는 String class를 사용하면
   성능 저하(데이터 누수)가 발생한다 => 이러한 문제를 해결하기 위해 StringBuffer를 사용한다.

		msg = "";
		//""의 객체가 1개
		msg += "안녕하세요";
		// ""+"안녕하세요" 를 담은 객체가 또하나
		msg += "저는 홍길동입니다.";
		// ""+"안녕하세요"+"저는 홍길동입니다" 를 담은 객체가 또하나
		msg += "저는 조선 세종대왕 시대에 살고있습니다.";
		// ""+"안녕하세요"+"저는 홍길동입니다"+"저는 조선~~"을 담은 객체가 또하나
		// 메서드 영역에 총 4개의 객체가 생긴것 
		// -> 안그래도 좁은 영역에 객체가 새로 또 4개나 생겨서 메모리 누수 발생
		// 나중엔 속도 저하까지 발생하게 됨 => StringBuffer를 사용해 메모리 관리
		
		따라서, 메모리를 효과적으로 관리하기 위해 
	
		StringBuffer sb = new StringBuffer();

		StirngBuffer 클래스로 객체를 만들어주고,
		그 안에 있는 append 메서드를 통해서 데이터를 축적해준다.

		sb.append("안녕하세요");
		sb.append("저는 홍길동입니다.");
		sb.append("저는 조선 세종대왕 시대에 살고있습니다.");
		
		// => 힙메모리에 StringBuffer를 이용해 메모리를 할당받고
		// 거기에 데이터를 축척해나감 -> 메모리 관리가 효과적!
		// 그럼 지금 StringBuffer에 저장된 데이터는
		// 안녕하세요 저는 홍길동입니다. 저는 조선 ~~ 이 다 저장되어있음
		// 근데 StringBuffer는 자주 쓰이는 class가 아니기 때문에
		// 데이터 축적이 완료되면 활용도가 높은 class인 String으로
		// 자료형을 변경해줘야 함.
		*활용도 : 파라미터의 자료형이나 반환형의 자료형으로 이용되는 정도
		
		msg = sb.toString();